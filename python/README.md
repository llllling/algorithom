# algorithom

#### 입출력

**2557, 1000, 2558, 10950, 10951, 10952, 10953, 11021, 11022, 11718, 11719,11720, 11721, 2741, 2742, 2739, 1924, 8393, 10818, 2438, 2439, 2440, 2441, 2442, 2445, 2522, 2446,10991, 10992**

#### DP

**1463, 11726, 11727, 9095, 10844, 11057, 2193, 9465, 2156, 11053, 11055, 11722, 11054, 1912, 2579, 1699, 2133, 9461, 2225, 2011, 11052**

#### 그다음

**2751, 11650, 11651, 10814, 10825, 10989, 11652, 11004, 10828, 9012, 10799,** 10845, 10866, 10808, 10809, 10820, 2743, 11655, 10824, 11656, 1406, 1158, 1168, 10430, 2609, 1934, 1850, 9613, 11005, 2745, 1373, 1212, 2089, 11576, 1978, 1929, 6588, 11653, 10872, 1676, 2004

#### 그래프(BFS, DFS)

dfs : 모든 노드를 방문하고자 하는 경우, 이동 시 가중치가 붙거나 이동 시 제약이 있는 경우 선택, 검색속도는 bfs에 비해 느림, 최단경로를 검색할 때 recursive하게 DFS를 구현하면 내가 원하는 vertex 간의 거리를 구할 수는 있다. 하지만 트리 형태라는 확증이 있어야 한다.
만약 그래프의 경우라면 내가 최종적으로 방문한 경로가 최단 경로인지 확신할 수 없기 때문이다. 이와 반대로, 트리의 경우라면 정점 간의 경로가 단 하나만 존재하기 때문에, 내가 방문한 경로는 무조건 최단 경로일 수밖에 없다.

bfs: 가중치가 없는 그래프, 가중치가 0이거나 1일 때 사용,두 노드사이의 최단경로 또는 임의의 경로 찾을 경우 선택, queue

ex) 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash 와 Vanessa 사이에 존재하는 경로를 찾는 경우

- 깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야할지도 모름
- 너비 우선 탐색의 경우 - Ash와 가까운 관계부터 탐색

다익스트라: 가중치가 여러 개가 존재한다면 사용, 시작점으로부터 나머지 정점까지의 최단경로를 구할 때 사용, 양의 간선만 사용가능

플로이드 와샬 : 모든정점에서 모든정점으로의 최단경로. 거쳐가는 정점을 기준으로 알고리즘을 수행해야함.그래프의 간선들 중 음의 가중치가 존재해도 실행된다. 플로이드 와샬의 기본 개념은 i에서 출발해 j로 가는 경로의 가중치를 저장하는 2차원 배열을 채우는데, i를 출발해 j로 바로 가는 것보다 k를 거쳐 j로 가는 게 효율적일 경우(저렴할 경우) 해당 값을 갱신해준다.

**1260, 11724, 1707, 10451, 2331, 9466, 2667,4963, 7576, 2178, 2146,** 1991, 11725, 1167, 1967

#### 이분탐색/삼분탐색

1654, 2805, 2110, 10815, 10816, 11662

#### 분할정복

- DP랑 거의 똑같은데, 부분문제의 답을 DP 테이블에 저장할 필요가 없는 부분이 DP랑 다른 점이다.
  11728, 1780, 11729, 1992, 2447, 2448, 1517, 2261

#### 그리디

11047, 2875, 10610, 1783, 1931, 11399, 2873, 1744

#### 완전탐색

1476, 1107, 1451, 9095, 10819, 10971, 1697, 1963, 9019, 1525, 2251, 2186, 3108, 5014, 1759, 2580, 1987, 6603, 1182, 2003, 1806, 1644, 1261, 1208, 7453, 2632, 2143
